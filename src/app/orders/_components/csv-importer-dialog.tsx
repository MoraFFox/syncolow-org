
"use client";

import { useState, useCallback, useMemo } from 'react';
import { useOrderStore } from '@/store/use-order-store';
import { Button } from '@/components/ui/button';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Progress } from '@/components/ui/progress';
import { ChevronDown, CheckCircle2 } from 'lucide-react';
import { Collapsible, CollapsibleTrigger, CollapsibleContent } from '@/components/ui/collapsible';
import { ScrollArea } from '@/components/ui/scroll-area';
import {
  FileUp,
  Loader2,
  CheckCircle,
  AlertTriangle,
  RefreshCw,
  Sparkles,
  ArrowLeft,
  ArrowRight,
  XCircle,
  FileText,
  Database,
  Download,
} from 'lucide-react';
import { toast } from '@/hooks/use-toast';
import { importFlow } from '@/ai/flows/import-flow';
import { ImportErrorList } from './ImportErrorList';
import type { CsvRow, ImportRowError, ImportableEntityType, Company, Product } from '@/lib/types';
import { ImportResolutionForm } from './ImportResolutionForm';
import { parseFile, detectDuplicates, calculateImportedOrderTotals } from '@/lib/file-import-utils';
import ColumnMappingStep from './column-mapping-step';
import { cn } from '@/lib/utils';
import { supabase } from '@/lib/supabase';
import { fixAllMissingEntities } from '@/lib/import-entity-fixer';

type ImportStage =
  | 'upload'
  | 'parsing'
  | 'mapping'
  | 'validating'
  | 'duplicate_checking'
  | 'validation_failed'
  | 'resolving'
  | 'importing'
  | 'import_complete'
  | 'success'
  | 'error';

interface CsvImporterDialogProps {
  fileType?: 'csv' | 'excel';
  isOpen: boolean;
  onOpenChange: (isOpen: boolean) => void;
  entityType: ImportableEntityType;
}

export function CsvImporterDialog({
  isOpen,
  onOpenChange,
  entityType,
  fileType = 'csv',
}: CsvImporterDialogProps) {
  const { fetchInitialData } = useOrderStore();
  const [file, setFile] = useState<File | null>(null);
  const [stage, setStage] = useState<ImportStage>('upload');
  const [errors, setErrors] = useState<ImportRowError[]>([]);
  const [isFixingAll, setIsFixingAll] = useState(false);
  const [autoGeneratedEntities, setAutoGeneratedEntities] = useState<{
    companies: string[];
    products: string[];
  }>({ companies: [], products: [] });
  const [importResult, setImportResult] = useState<{ importedCount: number; importedTotal?: number; skippedCount?: number } | null>(null);
  const [fileName, setFileName] = useState('');
  const [originalData, setOriginalData] = useState<CsvRow[]>([]);
  const [resolvedErrors, setResolvedErrors] = useState<Set<number>>(new Set());
  const [errorToFix, setErrorToFix] = useState<ImportRowError | null>(null);
  const [duplicatesInfo, setDuplicatesInfo] = useState<{
    withinFile: { duplicateIndices: number[]; duplicateMap: Map<string, number[]> };
    againstDatabase: { duplicateIndices: number[]; existingRecords: CsvRow[] };
  } | null>(null);
  const [showDuplicates, setShowDuplicates] = useState(false);
  
  const [importProgress, setImportProgress] = useState(0);
  const [importStageDetails, setImportStageDetails] = useState('');
  const [detailedErrorLog, setDetailedErrorLog] = useState<string[]>([]);
  const [showErrorLog, setShowErrorLog] = useState(false);
  const [criticalError, setCriticalError] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [errorLog, setErrorLog] = useState<{ timestamp: string; message: string; type?: string }[]>([]);
  const [importResults, setImportResults] = useState<{
    newOrders: any[];
    updatedOrders: any[];
    skippedOrders: any[];
  } | null>(null);
  
  const [mappedData, setMappedData] = useState<CsvRow[]>([]);
  
  const resetState = useCallback(() => {
    setFile(null);
    setStage('upload');
    setErrors([]);
    setIsFixingAll(false);
    setImportResult(null);
    setFileName('');
    setOriginalData([]);
    setMappedData([]);
    setResolvedErrors(new Set());
    setErrorToFix(null);
    setAutoGeneratedEntities({ companies: [], products: [] });
    const input = document.getElementById('csv-upload-dialog') as HTMLInputElement;
    if (input) input.value = '';
  }, []);

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const selectedFile = event.target.files?.[0];
    if (selectedFile) {
        const ext = selectedFile.name.split('.').pop()?.toLowerCase();
        const allowedTypes = fileType === 'csv' ? ['csv'] : ['xlsx', 'xls'];
        if (ext && allowedTypes.includes(ext)) {
            setFile(selectedFile);
            setFileName(selectedFile.name);
        } else {
            toast({
                title: 'Invalid file type',
                description: `Please select a ${fileType === 'csv' ? 'CSV' : 'Excel (XLSX or XLS)'} file.`,
                variant: 'destructive'
            });
        }
    } else {
        setFile(null);
        setFileName('');
    }
  };

   const runImport = useCallback(async (dataToImport: CsvRow[], isRerun: boolean = false) => {
     const CHUNK_SIZE = 1000; // Increased to improve performance, 50 was too conservative
     
     if (dataToImport.length > CHUNK_SIZE && !isRerun) {
       // Split into chunks and process sequentially
       setStage('importing');
       let totalImported = 0;
       let totalRevenue = 0;
       let totalSkipped = 0;
       let hasErrors = false;
       
       for (let i = 0; i < dataToImport.length; i += CHUNK_SIZE) {
         const chunk = dataToImport.slice(i, i + CHUNK_SIZE);
         setImportStageDetails(`Processing rows ${i + 1} to ${Math.min(i + CHUNK_SIZE, dataToImport.length)} of ${dataToImport.length}...`);
         setImportProgress(Math.round((i / dataToImport.length) * 100));
         
         try {
           const result = await importFlow({ entityType, data: chunk });
           if (result.success) {
             totalImported += result.importedCount;
             totalRevenue += result.importedTotal || 0;
             totalSkipped += result.skippedCount || 0;
           } else {
             // Handle errors but continue
             const blockingErrors = result.errors?.filter(e => e.blocking) || [];
             if (blockingErrors.length > 0) {
               setErrors(prev => [...prev, ...blockingErrors]);
               hasErrors = true;
             }
           }
         } catch (error: any) {
           toast({ title: 'Chunk import failed', description: error.message, variant: 'destructive' });
           return false;
         }
       }
       
       // All chunks processed - show final results
       setImportProgress(100);
       setImportResult({ importedCount: totalImported, importedTotal: totalRevenue, skippedCount: totalSkipped });
       
       if (hasErrors) {
         setStage('validation_failed');
         return false;
       }

       const skippedMsg = totalSkipped > 0 ? `, ${totalSkipped} duplicates skipped` : '';
       const totalMsg = ` | Total: $${totalRevenue.toFixed(2)}`;
       setDetailedErrorLog(prev => [...prev, `Import Successful: ${totalImported} ${entityType}s imported${skippedMsg}${totalMsg}`, `Time: ${new Date().toLocaleString()}`, '---']);
       
       setStage('import_complete');
       
       if (totalSkipped > 0) {
         toast({ title: 'Import Complete', description: `${totalImported} imported, ${totalSkipped} duplicates skipped` });
       }
       return true;
     }
     // Single chunk or rerun
     if (!isRerun) {
       setStage('validating');
       setImportProgress(0);
       setImportStageDetails(`Validating ${entityType} data...`);
     } else {
       setStage('importing');
       setImportProgress(0);
       setImportStageDetails('Re-validating single row...');
     }
     
     console.log('CLIENT: Data to import:', dataToImport.length, 'rows');
     console.log('CLIENT: Data size:', JSON.stringify(dataToImport).length, 'bytes');
     console.log('CLIENT: First row:', dataToImport[0]);
     
     // Switch to importing stage before calling importFlow
     if (!isRerun) {
       setStage('importing');
       setImportStageDetails(`Importing ${dataToImport.length} ${entityType}s...`);
     }
     
     try {
       console.log('CLIENT: Calling importFlow...');
       const result = await importFlow({ entityType, data: dataToImport });
       console.log('CLIENT: importFlow returned:', result);
 
       // Show results even if all were skipped
       setImportResult({ 
         importedCount: result.importedCount,
         importedTotal: result.importedTotal || 0,
         skippedCount: result.skippedCount || 0
       });
       
       const skippedMsg = result.skippedCount ? `, ${result.skippedCount} duplicates skipped` : '';
       const totalMsg = result.importedTotal ? ` | Total: $${result.importedTotal.toFixed(2)}` : '';
       setDetailedErrorLog(prev => [...prev, `Import Complete: ${result.importedCount} ${entityType}s imported${skippedMsg}${totalMsg}`, `Time: ${new Date().toLocaleString()}`, '---']);
       
       setStage('import_complete');
       
       if (result.skippedCount && result.skippedCount > 0) {
         toast({ title: 'Import Complete', description: `${result.importedCount} imported, ${result.skippedCount} duplicates skipped` });
       }
       
       if (result.success) {
         return true;
       } else {
         if (result.errors?.[0]?.errorMessage?.startsWith('Server Error:')) {
             const errorMessage = result.errors[0].errorMessage;
             const errorType = 'Server Error';
             toast({ title: 'A critical server error occurred', description: errorMessage, variant: 'destructive', duration: 20000 });
             setDetailedErrorLog(prev => [...prev, `Server Error: ${errorMessage}`, `Type: ${errorType}`, `Time: ${new Date().toLocaleString()}`, '---']);
             setErrorLog(prev => [...prev, {
               timestamp: new Date().toLocaleString(),
               message: `Server Error: ${errorMessage}`,
               type: 'server-error'
             }]);
             setCriticalError(errorMessage);
             setStage('upload');
             return false;
         }
 
         const blockingErrors = result.errors?.filter(e => e.blocking) || [];
         
         if (blockingErrors.length > 0) {
           if (isRerun && dataToImport.length === 1) {
             const errorDesc = `Could not import row ${dataToImport[0].rowIndex}. Reason: ${blockingErrors[0].errorMessage}`;
             toast({ title: "Resolution Failed", description: errorDesc, variant: "destructive" });
             setDetailedErrorLog(prev => [...prev, `Resolution Failed: ${errorDesc}`, `Time: ${new Date().toLocaleString()}`, '---']);
             setErrorLog(prev => [...prev, {
               timestamp: new Date().toLocaleString(),
               message: `Resolution Failed: ${errorDesc}`,
               type: 'resolution-error'
             }]);
             setStage('validation_failed');
             return false;
           }

           const currentResolved = new Set(resolvedErrors);
           const newErrors = blockingErrors.filter(e => !currentResolved.has(e.rowIndex));
           setErrors(prev => [...prev, ...newErrors]);
           if (newErrors.length > 0) {
               setStage('validation_failed');
               newErrors.forEach(error => {
                 setDetailedErrorLog(prev => [...prev, `Validation Error: Row ${error.rowIndex + 1}: ${error.errorMessage}`, `Time: ${new Date().toLocaleString()}`, '---']);
                 setErrorLog(prev => [...prev, {
                   timestamp: new Date().toLocaleString(),
                   message: `Validation Error: Row ${error.rowIndex + 1}: ${error.errorMessage}`,
                   type: 'validation-error'
                 }]);
               });
           } else {
               await runImport(originalData, true);
           }
         } else {
             // Partial success - some imported, some errors
             setImportResult({ 
               importedCount: result.importedCount,
               importedTotal: result.importedTotal || 0,
               skippedCount: result.skippedCount || 0
             });
             setStage('import_complete');
             setDetailedErrorLog(prev => [...prev, `Partial Import: ${result.importedCount} ${entityType}s imported`, `Time: ${new Date().toLocaleString()}`, '---']);
             setErrorLog(prev => [...prev, {
               timestamp: new Date().toLocaleString(),
               message: `Partial Import: ${result.importedCount} ${entityType}s imported`,
               type: 'partial-success'
             }]);
         }
         return true;
       }
     } catch (e: any) {
       const errorMessage = `Message: ${e.message}. Stack: ${e.stack}`;
       toast({ title: 'Fatal Error During Import', description: errorMessage, variant: 'destructive', duration: 3000 });
       setDetailedErrorLog(prev => [...prev, `Fatal Error: ${errorMessage}`, `Time: ${new Date().toLocaleString()}`, '---']);
       setCriticalError(errorMessage);
       setStage('upload');
       return false;
     }
   }, [entityType, fetchInitialData, resolvedErrors, originalData]);

  const handleParseAndMap = useCallback(async () => {
    if (!file) {
      toast({ title: 'No file selected', variant: 'destructive' });
      return;
    }
    setStage('parsing');
    setErrors([]);
    setResolvedErrors(new Set());
    
    try {
      const data = await parseFile(file);
      if (data.length === 0) {
        toast({ title: 'Empty or invalid file', variant: 'destructive' });
        setStage('upload');
        return;
      }
      setOriginalData(data);
      setStage('mapping');
    } catch (error: any) {
      const errorMessage = error.message || 'Failed to parse the file';
      const errorType = error.name || 'Parsing Error';
      toast({
        title: 'Parsing Error',
        description: errorMessage,
        variant: 'destructive'
      });
      setDetailedErrorLog(prev => [...prev, `Parsing Error: ${errorMessage}`, `Type: ${errorType}`, `Time: ${new Date().toLocaleString()}`, '---']);
      setErrorLog(prev => [...prev, {
        timestamp: new Date().toLocaleString(),
        message: `Parsing Error: ${errorMessage}`,
        type: 'parsing'
      }]);
      setCriticalError(errorMessage);
      setStage('upload');
    }
  }, [file]);

  const handleMappingComplete = (data: CsvRow[]) => {
    // Apply new pricing calculation: Total = ((Quantity × Unit Price) - Discount) × 1.14
    const dataWithCalculatedTotals = calculateImportedOrderTotals(data);
    setMappedData(dataWithCalculatedTotals);
    setStage('validating');
    setTimeout(() => runImport(dataWithCalculatedTotals), 100);
  };
  
  const handleFixError = (error: ImportRowError) => {
    setErrorToFix(error);
    setStage('resolving');
  };

  const handleFixAll = async () => {
    setIsFixingAll(true);
    setImportStageDetails('Creating missing entities...');

    try {
      let lastUpdate = 0;
      const result = await fixAllMissingEntities({
        errors,
        onProgress: (message) => {
          const now = Date.now();
          // Throttle updates to every 100ms to prevent UI freezing
          if (now - lastUpdate > 100) {
            console.log('[Fix All]', message);
            setImportStageDetails(message);
            lastUpdate = now;
          }
        },
      });

      if (result.success) {
        // Update the auto-generated entities state
        setAutoGeneratedEntities({
          companies: result.createdCompanies,
          products: result.createdProducts,
        });

        // Clear errors and retry import if entities were created
        if (result.createdCompanies.length > 0 || result.createdProducts.length > 0) {
          setErrors([]);
          setImportStageDetails('Retrying import with new entities...');
          await runImport(mappedData);
        }
      }
    } finally {
      setIsFixingAll(false);
      setImportStageDetails('');
    }
  };

  const handleResolutionSubmit = async (originalError: ImportRowError, createdEntity: Company | Product) => {
    const errorIndex = originalError.rowIndex;
    setResolvedErrors(prev => new Set(prev).add(errorIndex));
    await runImport([originalError.originalData!], true);
    setErrorToFix(null);
    setStage('validation_failed');
  };
  
  const handleDialogChange = (open: boolean) => {
    if (!open) {
      resetState();
      // Refresh data when dialog closes
      fetchInitialData().catch(console.error);
    }
    onOpenChange(open);
  };
  
  const allErrorsResolved = useMemo(() => {
    const blockingErrorIndexes = new Set(errors.filter(e => e.blocking).map(e => e.rowIndex));
    if (blockingErrorIndexes.size === 0) return false;
    return Array.from(blockingErrorIndexes).every(index => resolvedErrors.has(index));
  }, [errors, resolvedErrors]);

  const renderContent = () => {
    if (stage === 'mapping') {
      return (
        <ColumnMappingStep
          originalData={originalData}
          onMappingComplete={handleMappingComplete}
          onBack={() => {
            setStage('upload');
            setOriginalData([]);
          }}
          onSaveMapping={(mapping) => {
            // Handled in component
          }}
          onLoadMapping={(mapping) => {
            return {};
          }}
        />
      );
    }
    if (stage === 'resolving' && errorToFix) {
      return (
        <ImportResolutionForm
          errorToFix={errorToFix}
          onResolved={handleResolutionSubmit}
          onCancel={() => {
            setErrorToFix(null);
            setStage('validation_failed');
          }}
        />
      );
    }
    
    if (stage === 'upload' || stage === 'parsing' || stage === 'validating' || stage === 'duplicate_checking' || stage === 'importing') {
       return (
            <div className="flex flex-col items-center justify-center p-8 text-center space-y-4">
              {(stage === 'upload') && (
                <>
                  <label htmlFor="csv-upload-dialog" className="w-full">
                    <div className="flex flex-col items-center justify-center p-8 border-2 border-dashed rounded-lg cursor-pointer hover:bg-muted/50">
                        <FileUp className="h-10 w-10 text-muted-foreground" />
                        <span className="mt-2 text-sm text-muted-foreground">{fileName || `Click to select or drop a ${fileType === 'csv' ? 'CSV' : 'Excel'} file`}</span>
                    </div>
                    <Input id="csv-upload-dialog" type="file" accept={fileType === 'csv' ? '.csv' : '.xlsx,.xls'} onChange={handleFileChange} className="hidden" />
                  </label>
                </>
              )}
               {(stage !== 'upload') && (
                 <div className="w-full max-w-md space-y-4">
                    <div className="space-y-2">
                      <div className="flex justify-between text-sm">
                        <span className="font-medium">
                          {stage === 'parsing' ? 'Parsing file...' :
                           stage === 'validating' ? 'Validating data...' :
                           stage === 'duplicate_checking' ? 'Checking for duplicates...' :
                           stage === 'importing' ? 'Importing data...' : `${stage}...`}
                        </span>
                        <span>{importProgress}%</span>
                      </div>
                      <Progress value={importProgress} className="w-full" />
                      {importStageDetails && (
                        <p className="text-xs text-muted-foreground text-center">
                          {importStageDetails}
                        </p>
                      )}
                    </div>
                    <div className="flex flex-col items-center">
                      <Loader2 className="h-12 w-12 animate-spin text-primary mb-2" />
                      <p className="text-lg text-muted-foreground capitalize">
                        {stage === 'parsing' ? 'Parsing file...' :
                         stage === 'validating' ? 'Validating data...' :
                         stage === 'duplicate_checking' ? 'Checking for duplicates...' :
                         stage === 'importing' ? 'Importing data...' : 'Processing...'}
                      </p>
                      <p className="text-sm text-muted-foreground mt-1">
                        {stage === 'parsing' ? 'Analyzing file structure and extracting data...' :
                         stage === 'validating' ? 'Checking data format and required fields...' :
                         stage === 'duplicate_checking' ? 'Looking for duplicate entries...' :
                         stage === 'importing' ? 'Adding data to the system...' : 'Please wait...'}
                      </p>
                    </div>
                 </div>
               )}
            </div>
        );
    }

    if (stage === 'validation_failed' && showDuplicates && duplicatesInfo) {
      return (
        <div className="space-y-6">
          <div className="rounded-lg border bg-yellow-50 border-yellow-200 p-4 dark:bg-yellow-950/30 dark:border-yellow-800">
            <div className="flex items-start">
              <AlertTriangle className="h-4 w-4 mt-0.5 mr-3 text-yellow-600 dark:text-yellow-400" />
              <div className="flex-1">
                <h4 className="text-sm font-medium text-yellow-800 dark:text-yellow-200 mb-1">
                  Duplicate Records Detected
                </h4>
                <p className="text-sm text-yellow-700 dark:text-yellow-300">
                  We found potential duplicate records in your import. Please review the duplicates below and choose how to proceed.
                </p>
              </div>
            </div>
          </div>
          
          <div className="space-y-4">
            {duplicatesInfo.withinFile.duplicateIndices.length > 0 && (
              <div className="border rounded-lg p-4 bg-blue-50 dark:bg-blue-950/20">
                <h5 className="font-medium text-blue-800 dark:text-blue-200 mb-2 flex items-center">
                  <FileText className="h-4 w-4 mr-2" />
                  Duplicates Within File: {duplicatesInfo.withinFile.duplicateIndices.length} records
                </h5>
                <p className="text-sm text-blue-700 dark:text-blue-300 mb-3">
                  The following rows appear to be duplicates of each other within the import file:
                </p>
                <ul className="text-sm space-y-1">
                  {Array.from(duplicatesInfo.withinFile.duplicateMap.entries()).map(([key, indices]) => (
                    <li key={key} className="bg-white dark:bg-gray-800 p-2 rounded border">
                      <span className="font-medium">Rows: [{indices.join(', ')}]</span> - Potential duplicate group
                    </li>
                  ))}
                </ul>
              </div>
            )}
            
            {duplicatesInfo.againstDatabase.duplicateIndices.length > 0 && (
              <div className="border rounded-lg p-4 bg-orange-50 dark:bg-orange-950/20">
                <h5 className="font-medium text-orange-800 dark:text-orange-200 mb-2 flex items-center">
                  <Database className="h-4 w-4 mr-2" />
                  Duplicates Against Database: {duplicatesInfo.againstDatabase.duplicateIndices.length} records
                </h5>
                <p className="text-sm text-orange-700 dark:text-orange-300 mb-3">
                  The following rows match records that already exist in the database:
                </p>
                <ul className="text-sm space-y-1">
                  {duplicatesInfo.againstDatabase.existingRecords.map((record, idx) => {
                    const originalIdx = duplicatesInfo.againstDatabase.duplicateIndices[idx];
                    return (
                      <li key={originalIdx} className="bg-white dark:bg-gray-800 p-2 rounded border">
                        <span className="font-medium">Row {originalIdx + 1}:</span> Matches existing record for {record['Customer Name'] || record['CustomerName'] || 'N/A'} - {record['Item Name'] || record['ItemName'] || 'N/A'}
                      </li>
                    );
                  })}
                </ul>
              </div>
            )}
          </div>
          
          <div className="flex flex-col sm:flex-row gap-3 pt-4">
            <Button
              variant="outline"
              onClick={() => {
                setShowDuplicates(false);
                runImport(originalData);
              }}
              className="flex-1"
            >
              <ArrowRight className="h-4 w-4 mr-2" />
              Import Anyway (Keep Duplicates)
            </Button>
            <Button
              variant="secondary"
              onClick={() => {
                setStage('upload');
                setShowDuplicates(false);
              }}
              className="flex-1"
            >
              <XCircle className="h-4 w-4 mr-2" />
              Cancel Import
            </Button>
          </div>
        </div>
      );
    }

    if (stage === 'validation_failed') {
      const missingEntityErrors = errors.filter(e => e.errorType === 'missing-entity' && e.blocking);
      const hasMissingEntities = missingEntityErrors.length > 0;
      
      return (
        <div className="space-y-6">
          {hasMissingEntities && (
            <div className="flex justify-end">
              <Button 
                onClick={handleFixAll} 
                disabled={isFixingAll}
                variant="default"
              >
                {isFixingAll ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Creating Entities...
                  </>
                ) : (
                  <>
                    <Sparkles className="mr-2 h-4 w-4" />
                    Fix All
                  </>
                )}
              </Button>
            </div>
          )}
          <ImportErrorList
            errors={errors.filter(e => e.blocking)}
            onFix={handleFixError}
            resolvedErrors={resolvedErrors}
          />
          {allErrorsResolved && (
            <div className="mt-6 flex flex-col items-center gap-4 p-4 border-2 border-dashed rounded-lg bg-green-50 dark:bg-green-950/50">
               <CheckCircle className="h-8 w-8 text-green-500" />
               <h3 className="font-semibold">All errors addressed!</h3>
               <p className="text-sm text-muted-foreground">You can now run the final import.</p>
              <Button onClick={() => runImport(originalData, true)}>
                <RefreshCw className="mr-2 h-4 w-4" />
                Run Final Import
              </Button>
            </div>
          )}
          
          <div className="border rounded-lg p-4 bg-blue-50 dark:bg-blue-950/20 border-blue-200 dark:border-blue-800">
            <h4 className="font-medium text-blue-800 dark:text-blue-200 mb-2 flex items-center">
              <Sparkles className="h-4 w-4 mr-2" />
              Need Help?
            </h4>
            <p className="text-sm text-blue-700 dark:text-blue-300 mb-3">
              Common import issues and how to resolve them:
            </p>
            <ul className="text-sm text-blue-700 dark:text-blue-300 space-y-2 list-disc pl-5">
              <li><strong>Missing required fields:</strong> Ensure all mandatory columns ({entityType === 'company' ? 'Customer Name, Email, Phone' : 'Item Name, Price, Category'}) are present in your CSV/Excel file</li>
              <li><strong>Invalid data formats:</strong> Check that dates, prices, and other fields match the expected format (e.g., prices should be numeric values)</li>
              <li><strong>Duplicate records:</strong> Remove duplicate entries or choose to import anyway if duplicates are acceptable</li>
              <li><strong>Referenced entities don't exist:</strong> Create missing companies/branches before importing related orders</li>
              <li><strong>File encoding issues:</strong> Save your file as UTF-8 to avoid character encoding problems</li>
              <li><strong>Column headers mismatch:</strong> Ensure your column headers match the expected format (case insensitive)</li>
              <li><strong>Large file size:</strong> Try splitting your file into smaller batches for better performance</li>
            </ul>
          </div>
          
          <div className="mt-6 border rounded-lg overflow-hidden">
            <div className="w-full px-4 py-3 bg-muted/30 flex items-center justify-between">
              <button
                className="flex items-center text-left font-medium hover:text-primary transition-colors"
                onClick={() => setShowErrorLog(!showErrorLog)}
              >
                <FileText className="h-4 w-4 mr-2" />
                Detailed Error Log
                <ChevronDown
                  className={`h-4 w-4 ml-2 transition-transform duration-200 ${
                    showErrorLog ? 'rotate-180' : ''
                  }`}
                />
              </button>
              <Button
                variant="ghost"
                size="sm"
                onClick={() => {
                  const logContent = detailedErrorLog.join('\n');
                  const blob = new Blob([logContent], { type: 'text/plain' });
                  const url = URL.createObjectURL(blob);
                  const a = document.createElement('a');
                  a.href = url;
                  a.download = `import-log-${new Date().toISOString()}.txt`;
                  a.click();
                  URL.revokeObjectURL(url);
                }}
              >
                <Download className="h-4 w-4 mr-2" />
                Download Log
              </Button>
            </div>
            {showErrorLog && (
              <div className="max-h-60 overflow-y-auto border-t bg-muted/10 p-4">
                {detailedErrorLog.length > 0 ? (
                  <div className="space-y-2">
                    {detailedErrorLog.map((logEntry, index) => (
                      <div
                        key={index}
                        className={`text-xs p-2 rounded ${
                          logEntry.includes('Error:')
                            ? 'bg-red-50 dark:bg-red-950/30 text-red-700 dark:text-red-300'
                            : logEntry.includes('Time:') || logEntry.includes('Time:')
                              ? 'bg-gray-50 dark:bg-gray-900/30 text-gray-500 dark:text-gray-400 font-mono'
                              : logEntry.includes('Success:') || logEntry.includes('Complete:')
                                ? 'bg-green-50 dark:bg-green-950/30 text-green-700 dark:text-green-300'
                                : 'bg-muted/30'
                        }`}
                      >
                        {logEntry}
                      </div>
                    ))}
                  </div>
                ) : (
                  <p className="text-sm text-muted-foreground italic">No detailed logs available yet.</p>
                )}
              </div>
            )}
          </div>
        </div>
      );
    }

    if (stage === 'import_complete' && importResult) {
      const hasAutoGenerated = autoGeneratedEntities.companies.length > 0 || autoGeneratedEntities.products.length > 0;
      
      return (
        <div className="space-y-6">
          <Alert variant="default" className="bg-green-50 border-green-200 text-green-800 dark:bg-green-950 dark:border-green-800 dark:text-green-300">
            <CheckCircle className="h-4 w-4 !text-green-600" />
            <AlertTitle>Import Complete!</AlertTitle>
            <AlertDescription className="text-green-700 dark:text-green-400">
              <p>Successfully imported {importResult.importedCount} {entityType}(s).</p>
              <p className="mt-2 text-sm">The imported data has been added to your {entityType.toLowerCase()} list and is now available in the system.</p>
              {hasAutoGenerated && (
                <p className="mt-2 text-sm font-medium">
                  {autoGeneratedEntities.companies.length > 0 && `${autoGeneratedEntities.companies.length} companies `}
                  {autoGeneratedEntities.products.length > 0 && `${autoGeneratedEntities.products.length} products `}
                  were auto-generated and need more information.
                </p>
              )}
            </AlertDescription>
          </Alert>
          
          {hasAutoGenerated && (
            <Alert className="bg-yellow-50 border-yellow-200 dark:bg-yellow-950/30 dark:border-yellow-800">
              <AlertTriangle className="h-4 w-4 text-yellow-600" />
              <AlertTitle className="text-yellow-800 dark:text-yellow-200">Auto-Generated Entities Need Attention</AlertTitle>
              <AlertDescription className="text-yellow-700 dark:text-yellow-300">
                <p className="mb-2">The following entities were automatically created with minimal information:</p>
                {autoGeneratedEntities.companies.length > 0 && (
                  <div className="mb-2">
                    <p className="font-medium">Companies ({autoGeneratedEntities.companies.length}):</p>
                    <ul className="list-disc list-inside text-sm">
                      {autoGeneratedEntities.companies.map((name, idx) => (
                        <li key={idx}>{name}</li>
                      ))}
                    </ul>
                  </div>
                )}
                {autoGeneratedEntities.products.length > 0 && (
                  <div>
                    <p className="font-medium">Products ({autoGeneratedEntities.products.length}):</p>
                    <ul className="list-disc list-inside text-sm">
                      {autoGeneratedEntities.products.map((name, idx) => (
                        <li key={idx}>{name}</li>
                      ))}
                    </ul>
                  </div>
                )}
                <p className="mt-2 text-sm">Please update these entities with complete information.</p>
              </AlertDescription>
            </Alert>
          )}
          
          <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
            <div className="border rounded-lg p-4 bg-white dark:bg-gray-800">
              <h4 className="text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Total Imported</h4>
              <p className="text-2xl font-bold text-green-600 dark:text-green-400">{importResult.importedCount}</p>
            </div>
            {importResult.skippedCount !== undefined && importResult.skippedCount > 0 && (
              <div className="border rounded-lg p-4 bg-white dark:bg-gray-800">
                <h4 className="text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Duplicates Skipped</h4>
                <p className="text-2xl font-bold text-yellow-600 dark:text-yellow-400">{importResult.skippedCount}</p>
              </div>
            )}
            {importResult.importedTotal !== undefined && (
              <div className="border rounded-lg p-4 bg-white dark:bg-gray-800">
                <h4 className="text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Total Revenue</h4>
                <p className="text-2xl font-bold text-blue-600 dark:text-blue-400">${importResult.importedTotal.toFixed(2)}</p>
              </div>
            )}
            <div className="border rounded-lg p-4 bg-white dark:bg-gray-800">
              <h4 className="text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Status</h4>
              <p className="text-2xl font-bold text-purple-600 dark:text-purple-400">Success</p>
            </div>
          </div>
          
          <div className="border rounded-lg p-4 bg-blue-50 dark:bg-blue-950/20 border-blue-200 dark:border-blue-800">
            <h4 className="font-medium text-blue-800 dark:text-blue-200 mb-2 flex items-center">
              <Sparkles className="h-4 w-4 mr-2" />
              What's Next?
            </h4>
            <ul className="text-sm text-blue-700 dark:text-blue-300 space-y-1 list-disc pl-5">
              <li>The imported {entityType.toLowerCase()} data is now visible in the main {entityType.toLowerCase()} list</li>
              <li>Any orders associated with these {entityType.toLowerCase()} have been updated with the new information</li>
              <li>If you need to make adjustments, you can edit the {entityType.toLowerCase()} directly from the list view</li>
            </ul>
          </div>
          
          <div className="border rounded-lg p-4 bg-emerald-50 dark:bg-emerald-950/20 border-emerald-200 dark:border-emerald-800">
            <h4 className="font-medium text-emerald-800 dark:text-emerald-200 mb-2 flex items-center">
              <CheckCircle2 className="h-4 w-4 mr-2" />
              Success Notification
            </h4>
            <p className="text-sm text-emerald-700 dark:text-emerald-300 mb-3">
              Your import was successful! Here are some key points to note:
            </p>
            <ul className="text-sm text-emerald-700 dark:text-emerald-300 space-y-1 list-disc pl-5">
              <li>All {importResult.importedCount} {entityType}(s) have been successfully added to your system</li>
              <li>Related records have been updated automatically</li>
              <li>Data integrity has been maintained throughout the process</li>
              <li>The import has been logged for audit purposes</li>
            </ul>
          </div>
        </div>
      );
    }

    if (stage === 'success') {
      return (
        <div className="w-full max-w-md space-y-4">
          <div className="flex justify-center">
            <div className="rounded-full bg-green-100 p-3">
              <CheckCircle2 className="h-12 w-12 text-green-600" />
            </div>
          </div>
          <div className="text-center space-y-2">
            <h3 className="text-lg font-semibold text-green-600">Import Successful!</h3>
            <p className="text-muted-foreground">
              {`Successfully imported ${importResults?.newOrders?.length || 0} new orders, ${importResults?.updatedOrders?.length || 0} updated orders, and ${importResults?.skippedOrders?.length || 0} skipped orders.`}
            </p>
          </div>
        </div>
      );
    }
    
    if (stage === 'error') {
      return (
        <div className="w-full max-w-md space-y-4">
          <div className="flex justify-center">
            <div className="rounded-full bg-destructive/20 p-3">
              <AlertTriangle className="h-12 w-12 text-destructive" />
            </div>
          </div>
          <div className="text-center space-y-2">
            <h3 className="text-lg font-semibold text-destructive">Import Failed</h3>
            <p className="text-muted-foreground">
              {error || 'An error occurred during import. Please check the details below.'}
            </p>
          </div>
          {errorLog.length > 0 && (
            <div className="mt-4">
              <Collapsible className="w-full">
                <CollapsibleTrigger asChild>
                  <Button variant="outline" className="w-full justify-between">
                    View Error Details
                    <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
                  </Button>
                </CollapsibleTrigger>
                <CollapsibleContent className="mt-4 space-y-2 max-h-60 overflow-y-auto border rounded-md p-4">
                  <h4 className="font-medium">Error Log:</h4>
                  <ScrollArea className="h-40 w-full rounded-md border p-2">
                    {errorLog.map((log, index) => (
                      <div key={index} className="text-sm p-1 border-b last:border-b-0">
                        <div className="font-medium">{log.timestamp}</div>
                        <div className="text-muted-foreground">{log.message}</div>
                      </div>
                    ))}
                  </ScrollArea>
                </CollapsibleContent>
              </Collapsible>
            </div>
          )}
        </div>
      );
    }

    return null;
  };

  
    return (
      <Dialog open={isOpen} onOpenChange={handleDialogChange}>
        <DialogContent className="max-w-3xl max-h-[90vh] flex flex-col">
          <DialogHeader>
             {stage === 'resolving' ? null : (
               <>
                 <DialogTitle>Import {entityType} data from {fileType === 'csv' ? 'CSV' : 'Excel'}</DialogTitle>
                 {stage !== 'upload' && stage !== 'import_complete' && stage !== 'success' && stage !== 'error' && (
                   <div className="flex items-center gap-2 text-sm text-muted-foreground mt-2">
                     <div className={cn(
                       "flex items-center gap-1",
                       stage === 'parsing' && "text-primary font-medium"
                     )}>
                       <div className={cn(
                         "h-2 w-2 rounded-full",
                         stage === 'parsing' ? "bg-primary" : "bg-muted-foreground"
                       )} />
                       Parse
                     </div>
                     <div className="h-px w-4 bg-muted-foreground" />
                     <div className={cn(
                       "flex items-center gap-1",
                       stage === 'mapping' && "text-primary font-medium"
                     )}>
                       <div className={cn(
                         "h-2 w-2 rounded-full",
                         stage === 'mapping' ? "bg-primary" : "bg-muted-foreground"
                       )} />
                       Map Columns
                     </div>
                     <div className="h-px w-4 bg-muted-foreground" />
                     <div className={cn(
                       "flex items-center gap-1",
                       (stage === 'validating' || stage === 'validation_failed') && "text-primary font-medium"
                     )}>
                       <div className={cn(
                         "h-2 w-2 rounded-full",
                         (stage === 'validating' || stage === 'validation_failed') ? "bg-primary" : "bg-muted-foreground"
                       )} />
                       Validate
                     </div>
                     <div className="h-px w-4 bg-muted-foreground" />
                     <div className={cn(
                       "flex items-center gap-1",
                       stage === 'importing' && "text-primary font-medium"
                     )}>
                       <div className={cn(
                         "h-2 w-2 rounded-full",
                         stage === 'importing' ? "bg-primary" : "bg-muted-foreground"
                       )} />
                       Import
                     </div>
                   </div>
                 )}
               </>
             )}
          </DialogHeader>
          <div className="flex-1 overflow-y-auto pr-6 -mr-6">
            {renderContent()}
          </div>
          <DialogFooter className="pt-4 border-t gap-2">
             {stage === 'upload' && (
                  <>
                      <Button variant="outline" onClick={() => handleDialogChange(false)}>Cancel</Button>
                      <Button onClick={handleParseAndMap} disabled={!file}>Validate & Map Columns</Button>
                  </>
             )}
              {(stage === 'validation_failed' || stage === 'import_complete' || stage === 'success' || stage === 'error') && (
                   <Button variant="outline" onClick={() => handleDialogChange(false)}>
                      {stage === 'import_complete' ? 'Finish' : stage === 'success' ? 'Done' : stage === 'error' ? 'Close' : 'Close'}
                  </Button>
              )}
          </DialogFooter>
        </DialogContent>
      </Dialog>
    );
  }

    
